<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>How to make wallhacks for Among Us - Pentester, wtf!?</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="How to make wallhacks for Among Us"><meta property="og:description" content="Alternatively: ghetto protocol analysis and how to hack your way to cheat in Among Us"><meta property="og:type" content="article"><meta property="og:url" content="/blog/2020-10-16-amongus/"><meta property="article:published_time" content="2020-10-18T18:00:00+10:00"><meta property="article:modified_time" content="2020-10-18T18:00:00+10:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to make wallhacks for Among Us"><meta name=twitter:description content="Alternatively: ghetto protocol analysis and how to hack your way to cheat in Among Us"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:500,100,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css></head><body><div class="container wrapper post"><div class=header><a href=/><img src=/images/header.png alt="Break things, write reports"></a><div class=site-description></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>How to make wallhacks for Among Us</h1><div class=meta>Posted at &mdash; Oct 18, 2020</div></div><div class=markdown><p>&ldquo;Among Us is an online multiplayer social deduction game developed and published by American game studio InnerSloth and released on June 15, 2018. The game takes place in a space-themed setting in which players each take on one of two roles, most being Crewmates, and a predetermined number being Impostors.&rdquo;</p><ul><li><a href=https://en.wikipedia.org/wiki/Among_Us>https://en.wikipedia.org/wiki/Among_Us</a></li></ul><p>It&rsquo;s a pretty nifty game, where you need to figure out who the bad guys are, while completing mundane tasks. If you&rsquo;re the imposter, you need to kill everyone else before they complete the tasks. Alternatively, if you&rsquo;re super bored, and have a Friday afternoon, you can also use it as practice for protocol analysis. Ultimately, to cheat in this game you&rsquo;d want at least one of the following:</p><ul><li>Positional information:<ul><li>Where are people going?</li><li>Did they lie about where that was?</li><li>Did they make a move where it&rsquo;d be impossible for a normal player to do? i.e. Crawl through a vent</li></ul></li><li>Tasking information:<ul><li>What tasks do people have?</li><li>How does being an imposter get tasked?</li><li>Can we figure out who the imposter is at round start?</li></ul></li></ul><p>After some quick time with procdump, observing the &lsquo;Among Us.exe&rsquo; process, it appears that it has the following characteristics for communications:</p><ul><li>Usually port 22023, 22223, or a handful of others (Usually the port number is offset by a few hundreds: 22023, 22523, etc&mldr;)</li><li>UDP</li><li>Small message sizes (Largest has been 400 bytes, smallest 1 byte)</li></ul><p>Not uncommon for games to pick UDP over TCP; as you get better latency with UDP, and don&rsquo;t need to worry about window sizes. You end up needing to handle packets that may be received out of order, so there may be a counter or other field to indicate some kind of ordering. After some quick fiddling with wireshark, we had some packet captures of an empty lobby. Curiously, without anything happening in the game, messages were being sent and received. These are likely some kind of keep-alive.</p><p>With a lot of fiddling with installing scapy on Windows 10, I ended up with a small script to start capturing and displaying messages, with the intent to identify commonalities between them. This gave the following outputs, noting SourcePort, DestinationPort, Size in bytes, and the raw payload:</p><pre><code>
PS D:\Among Us\script&gt; python .\dump.py | Select -First 20
22023 -&gt; 57201 [Size: 18] : 0a0017ff0000000000000000000000000000
22023 -&gt; 57201 [Size: 18] : 0c000f00000000fc24683e6115ad0180b41a
57201 -&gt; 22023 [Size: 4] : 0a000fff
57201 -&gt; 22023 [Size: 3] : 0c0018
22023 -&gt; 57201 [Size: 18] : 0a0018ff000000bf807f1f8700c1c28015bc
57201 -&gt; 22023 [Size: 3] : 0c0019
22023 -&gt; 57201 [Size: 18] : 0c0010000000008fd56c95a4d99840d52907
57201 -&gt; 22023 [Size: 4] : 0a0010ff
22023 -&gt; 57201 [Size: 18] : 0a0019ff0000000001000000005920ff980d
57201 -&gt; 22023 [Size: 3] : 0c001a
22023 -&gt; 57201 [Size: 18] : 0a001aff0000005000000000500204000850
22023 -&gt; 57201 [Size: 18] : 0c00110000000090c855f73acc4dd1838144
57201 -&gt; 22023 [Size: 4] : 0a0011ff
57201 -&gt; 22023 [Size: 3] : 0c001b
22023 -&gt; 57201 [Size: 18] : 0a001bff0000000f0abe2a5a59326aa2d905
57201 -&gt; 22023 [Size: 3] : 0c001c
22023 -&gt; 57201 [Size: 18] : 0c001200000000385d38433853384b385b38
57201 -&gt; 22023 [Size: 4] : 0a0012ff
22023 -&gt; 57201 [Size: 18] : 0a001cff000000b942fedac6c51b802d89b7
57201 -&gt; 22023 [Size: 35] : 01001d1d00054a4a524d160002040d137465737420626c6f6220676f65732068657265

</code></pre><p>Curiously we can see a few interesting things here already:</p><ul><li>From <code>57201 -> 22023</code>, we&rsquo;re seeing 3 and 4 byte packets.<ul><li>This is client-to-server communications (High order/ephemeral port to 22023, the server port)</li></ul></li><li>Note the 3 byte payloads are incrementing: <code>0c0018</code>, <code>0c0019</code>, <code>0c001a</code>, <code>0c001b</code>.<ul><li>This is likely some kind of counter used for either Keep-Alives, or registering some kind of tick for handling packets out of order</li><li>These seem to start with <code>0x0c00</code></li><li>Note: This later turned out to be a counter after <code>0xc0</code>, due to seeing value&rsquo;s such as <code>0xc014c</code>, which appeared to increment</li></ul></li><li>Note the 3 byte payloads are also incrementing: <code>0a000fff</code>, <code>0a0010ff</code>, <code>0a0011ff</code>, <code>0a0012ff</code><ul><li>It&rsquo;s unclear why it&rsquo;s incrementing the second last byte rather than final byte</li><li>Probably also some kind of keep-alive or used to describe client&rsquo;s current time/state tracking</li><li>Seems to start with a <code>0x0a00</code></li></ul></li><li>From <code>22023 -> 57201</code>, we&rsquo;re seeing these 18 byte packets.<ul><li>These are server-to-client communications (22023 to high order/ephemeral port)</li><li>They start with an <code>0x0a00</code>, or an <code>0x0c00</code>, this could indicate some kind of type</li><li>Probably some kind of coorelation to the <code>0x0c</code> and <code>0x0a</code> messages from the server</li></ul></li></ul><p>It&rsquo;s unlikely we care about these keep-alive like ticks, they don&rsquo;t appear to have positional information or anything one would use for 1337 haxx.</p><p>Given we&rsquo;re seeing obvious counters, and nothing that looks like a CRC/checksum, or any fields that seem to be changing seemingly randomly - it&rsquo;s unlikely the protocol is encrypted, or at least these message types are not.</p><p>A strong indication that none of the protocol may not be encrypted is the 35 byte message observed, when observed in a hexdump output appears as the following:</p><pre><code>00000000  01 00 1d 1d 00 05 4a 4a 52 4d 16 00 02 04 0d 13  |......JJRM......|
00000010  74 65 73 74 20 62 6c 6f 62 20 67 6f 65 73 20 68  |test blob goes h|
00000020  65 72 65                                         |ere|
</code></pre><p>Noting the &lsquo;test blob goes here&rsquo; part, and that this was an in-game chat message sent by myself sitting in an empty lobby.</p><p>With a little bit of in-game knowledge of messages being capped to 100 characters, the single-byte field at <code>0xf</code> with value <code>0x13</code> is decimal 19, which is the length of the message.</p><p>The bytes at the start of the payload, from <code>0x00</code> to <code>0xE</code> don&rsquo;t appear immediately obvious, other than perhaps another counter field or two, or maybe a game identifier?</p><p>Jumping on the more interesting bits, if one wanted to cheat they&rsquo;d look for things like:</p><ul><li>Can we get information for other players locations (i.e. Wallhacks)</li><li>Can we figure out who the imposter is at start (knowing the game needs to tell people what their jobs are at start)</li></ul><p>Looking at the game start, we usually see a single, fairly large packet come in of interest:</p><pre><code>22023 -&gt; 52484 [Size: 277] : 0100010f01100c0100160000ac6874da0756b25c0980056b6f7669640498030001051800008ba24475075631650480075245414348454c09970100010a190000ac69a3410756ddd40d8008686f74206769726c03b30200010a1b0000ac69e79a0756ae4808800a77696e79752073616d6101d30800010a180000ac69a1470756cf791080074b41525448494b01ef0100010a150000ac6872eb0756328d0e80056b72757469015800010a180000ac69da960756800a128007756420656b206806932b00010a190000ac68594007564f1c1580094d656761426c6173740733000108170000671d468a075660f80e80067a61696e616c01941600010a170000671d468a075657f80e8006506c6179657201e911000104
</code></pre><p>Again in a hexdump:</p><pre><code>00000000  01 00 01 0f 01 10 0c 01 00 16 00 00 ac 68 74 da  |............¬htÚ|
00000010  07 56 b2 5c 09 80 05 6b 6f 76 69 64 04 98 03 00  |.V²\...kovid....|
00000020  01 05 18 00 00 8b a2 44 75 07 56 31 65 04 80 07  |......¢Du.V1e...|
00000030  52 45 41 43 48 45 4c 09 97 01 00 01 0a 19 00 00  |REACHEL.........|
00000040  ac 69 a3 41 07 56 dd d4 0d 80 08 68 6f 74 20 67  |¬i£A.VÝÔ...hot g|
00000050  69 72 6c 03 b3 02 00 01 0a 1b 00 00 ac 69 e7 9a  |irl.³.......¬iç.|
00000060  07 05 06 ae 48 08 80 0a 77 69 6e 79 75 20 73 61  |...®H...winyu sa|
00000070  6d 61 01 d3 08 00 01 0a 18 00 00 ac 69 a1 47 07  |ma.Ó.......¬i¡G.|
00000080  56 cf 79 10 80 07 4b 41 52 54 48 49 4b 01 ef 01  |VÏy...KARTHIK.ï.|
00000090  00 01 0a 15 00 00 ac 68 72 eb 07 56 32 8d 0e 80  |......¬hrë.V2...|
000000a0  05 6b 72 75 74 69 01 58 00 01 0a 18 00 00 ac 69  |.kruti.X......¬i|
000000b0  da 96 07 56 80 0a 12 80 07 75 64 20 65 6b 20 68  |Ú..V.....ud ek h|
000000c0  06 93 2b 00 01 0a 19 00 00 ac 68 59 40 07 56 4f  |..+......¬hY@.VO|
000000d0  1c 15 08 00 09 4d 65 67 61 42 6c 61 73 74 07 33  |.....MegaBlast.3|
000000e0  00 01 08 17 00 00 67 1d 46 8a 07 56 60 f8 0e 80  |......g.F..V`ø..|
000000f0  06 7a 61 69 6e 61 6c 01 94 16 00 01 0a 17 00 00  |.zainal.........|
00000100  67 1d 46 8a 07 56 57 f8 0e 80 06 50 6c 61 79 65  |g.F..VWø...Playe|
00000110  72 01 e9 11 00 01 04                             |r.é....|
</code></pre><p>We see the following little tidbits:</p><ul><li>ASCII strings for player names (<code>kovid</code>, <code>REACHEL</code>, <code>hot girl</code>)</li><li>These are not null terminated, but have a single byte prefix for length (i.e. <code>0x7</code> for <code>REACHEL</code>)</li><li>Players seem to start with <code>0x80</code> (except for MegaBlast?), and then is followed by the length of the character name</li><li>A player&rsquo;s record might go for 6 bytes past the last character of their name (See <code>Player</code> and the trailing bytes at <code>0x111</code>)</li><li>There might be 13 bytes between the start of a player name and the start of their record (See <code>zainal</code> and <code>Player</code> distance, minus <code>0x6</code> bytes)</li><li><code>0x00</code>, <code>0x00</code> has some kind of significance, as we&rsquo;re seeing this near the presumed start of a record, and we&rsquo;re observing 10 of these records (which lines up with our player count!)</li></ul><p>With this in mind, the player named <code>Player</code> record would be as follows:</p><pre><code>00000000  00 00 67 1d 46 8a 07 56 57 f8 0e 80 06 50 6c 61  |..g.F..VWø...Pla|
00000010  79 65 72 01 e9 11 00 01 04                       |yer.é....|
</code></pre><p><code>REACHEL</code> as follows:</p><pre><code>00000000  00 00 8b a2 44 75 07 56 31 65 04 80 07 52 45 41  |...¢Du.V1e...REA|
00000010  43 48 45 4c 09 97 01 00 01 0a                    |CHEL......|
</code></pre><p>And to confirm our suspicions, <code>hot girl</code>:</p><pre><code>00000000  00 00 ac 69 a3 41 07 56 dd d4 0d 80 08 68 6f 74  |..¬i£A.VÝÔ...hot|
00000010  20 67 69 72 6c 03 b3 02 00 01 0a                 | girl.³....|
</code></pre><p>Curiously with this, we have 1 byte between player records. These bytes are just before the <code>0x00</code>, <code>0x00</code> record. The value&rsquo;s above appear to be sporadic but not random, and are as follows:</p><pre><code>kovid: 0x16, 0x00, 0x00
REACHEL: 0x18, 0x00, 0x00
Hot Girl: 0x19, 0x00, 0x00
MegaBlast: 0x19, 0x00, 0x00
winyu sama.: 0x1b, 0x00, 0x00
KARTHIK: 0x18, 0x00, 0x00
kruti: 0x15, 0x00, 0x00
zainal: 0x17, 0x00, 0x00
ud ek h: 0x18, 0x00, 0x00
Player: 0x17, 0x00, 0x00

</code></pre><p>This preamble byte doesn&rsquo;t stand out as an immediate candidate for faction, although it could be a bitmask for tasking?</p><p>With the preamble out of the way, the start of the payload is as follows:</p><pre><code>00000000  01 00 01 0f 01 10 0c 01 00
</code></pre><p>I&rsquo;m still unsure what it means sadly!</p><p>Moving off to another part of the game, I started observing what was happening in real-time with scapy and ignoring things like heartbeats. This came out of a small script made just so I could observe messages on my second monitor, shown below:</p><pre><code>from scapy.all import sniff, Packet, UDP, PcapReader
import sys

def process(p: Packet):
    &quot;&quot;&quot;
    Hacky little format string printer.
    &quot;&quot;&quot;
    if len(p[UDP].payload) == 3 or len(p[UDP].payload) == 4 or len(p[UDP].payload) == 18:
        pass
    print(p[UDP].sport,&quot;-&gt;&quot;, p[UDP].dport, &quot;[Size: {}]&quot;.format(len(p[UDP].payload)),&quot;:&quot;, bytes(p[UDP].payload).hex())


sniff(filter=&quot;udp port {}&quot;.format(sys.argv[1]), prn=process)
</code></pre><p>Starting up a server and starting to move around, I saw the following communications of interest:</p><pre><code>PS D:\Among Us\script&gt; python .\livedump.py 22523
61235 -&gt; 22523 [Size: 22] : 00120005f069a48c0b0001062a00b182cd82ff77ff7f
61235 -&gt; 22523 [Size: 22] : 00120005f069a48c0b0001062b005c81cd82ff77ff7f
61235 -&gt; 22523 [Size: 22] : 00120005f069a48c0b0001062c001881cd82ff7fff7f
61235 -&gt; 22523 [Size: 22] : 00120005f069a48c0b0001062d001881cd82ff7fff7f
61235 -&gt; 22523 [Size: 22] : 00120005f069a48c0b0001062e001881cd82ff7fff7f
61235 -&gt; 22523 [Size: 22] : 00120005f069a48c0b0001062f0018815683ff7fff87
</code></pre><p>Making it a bit easier on myself, I started moving downward only:</p><pre><code>52300 -&gt; 22423 [Size: 22] : 001200052210cf8c0b0001065f014380c583ff7fff77
52300 -&gt; 22423 [Size: 22] : 001200052210cf8c0b000106600143807082ff7fff77
52300 -&gt; 22423 [Size: 22] : 001200052210cf8c0b000106610143801b81ff7fff77
52300 -&gt; 22423 [Size: 22] : 001200052210cf8c0b00010662014380c57fff7fff77
52300 -&gt; 22423 [Size: 22] : 001200052210cf8c0b000106630143803d7fff7fff7f
52300 -&gt; 22423 [Size: 22] : 001200052210cf8c0b000106640143803d7fff7fff7f
52300 -&gt; 22423 [Size: 22] : 001200052210cf8c0b000106650143803d7fff7fff7f
</code></pre><p>The following observations could be made:</p><ul><li>This is my client sending communications up to the server</li><li>The 15th and 17th byte seem to change when I&rsquo;m moving in directions</li><li>The 12th byte seems to be static per player, probably a player ID?<ul><li>Note: This was later tested and found to be different per player, so it&rsquo;s likely to be a player identifer for the session</li></ul></li><li>The first 10 bytes seem static, or at least didn&rsquo;t change in my sample size<ul><li>At best, it&rsquo;s a game identifier and some other things that are unique to the session</li><li>At worst, it&rsquo;s a big set of fields that haven&rsquo;t rolled over because it&rsquo;s a timestamp or large number</li></ul></li><li>The first 10 bytes are probably a handful of seperate fields</li></ul><p>Testing the hypothesis of the 15th, 17th and 12th bytes being significant, the following modfifications were made:</p><pre><code>from scapy.all import sniff, Packet, UDP, PcapReader
import sys

def processMovement(p: Packet):
    &quot;&quot;&quot;
    Figures out player ID and movement
    Outputs in a neat little CSV for graphing
    &quot;&quot;&quot;
    playerID = bytes(p[UDP].payload)[11:12].hex()
    playerX = bytes(p[UDP].payload)[15]
    playerY = int(bytes(p[UDP].payload)[17:18].hex(),16)
    return playerID, playerX, playerY

def process(p: Packet):
    &quot;&quot;&quot;
    Hacky little format string printer.
    &quot;&quot;&quot;
    if len(p[UDP].payload) == 22:
        id, x, y = processMovement(p)
        print(p[UDP].sport,&quot;-&gt;&quot;, p[UDP].dport, &quot;{},{},{}&quot;.format(id,x,y))


sniff(filter=&quot;udp port {}&quot;.format(sys.argv[1]), prn=process)
</code></pre><p>With the following outputs:</p><pre><code>52300 -&gt; 22423 06,125,137
52300 -&gt; 22423 06,124,137
52300 -&gt; 22423 06,123,136
52300 -&gt; 22423 06,122,135
52300 -&gt; 22423 06,121,134
52300 -&gt; 22423 06,120,133
52300 -&gt; 22423 06,120,132
52300 -&gt; 22423 06,120,131
52300 -&gt; 22423 06,120,129
52300 -&gt; 22423 06,121,128
52300 -&gt; 22423 06,122,127
52300 -&gt; 22423 06,123,127
52300 -&gt; 22423 06,124,127
</code></pre><p>This appeared to be on the right track for the following reasons:</p><ul><li>The numbers are not jumping around significantly (i.e. we&rsquo;re moving at some small movement speed)</li><li>When moving on one axis, only one field is changing</li><li>The maps seem small enough where a size of 255 is probably going to fit both horizontally and vertically (i.e. single byte)</li></ul><p>Other fields were observed but unclear what they meant:</p><ul><li>Position 12 seemed to be a counter used to indicate in what order the client sent the message<ul><li>Probably used to handle out of order comms</li></ul></li><li>Other bytes seemed to indicate if the player was starting/stopping movement (Byte 22/ Byte 19)</li><li>We ultimately don&rsquo;t care what they mean given we have positional information</li></ul><p>To ensure the data doesn&rsquo;t seem broken, I moved the character around the lobby walls and graphed the data.</p><p><img src=/img/amongus-lobby.png alt="Graphing coordinates of Player"></p><p>Fairly confident this maps out with the lobby walls.</p><p>Doing this with a real game, isolating to just a single player ID we get the following:</p><p><img src=/img/amongus-oneplayer.png alt="Graphing coordinates of Player, post-game"></p><p>Overlayed, this looks like the following:</p><p><img src=/img/amongus-overlay.png alt="Graphing coordinates of Player, with overlay!"></p><p>If one was so inclined, a dodgy player <em>could</em> decide to draw a graph and show where the players are at all times&mldr;</p></div></div><div class="footer wrapper"><nav class=nav><div></div></nav></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-141761824-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>