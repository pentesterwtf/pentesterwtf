<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Password Audit and Control Guidance - Active Directory - Pentester, wtf!?</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Password Audit and Control Guidance - Active Directory"><meta property="og:description" content="Stopping users from having stupid passwords in AD"><meta property="og:type" content="article"><meta property="og:url" content="/blog/2019/auditing-windows-ad-passwords/"><meta property="article:published_time" content="2019-07-16T00:00:00+10:00"><meta property="article:modified_time" content="2019-07-16T00:00:00+10:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Password Audit and Control Guidance - Active Directory"><meta name=twitter:description content="Stopping users from having stupid passwords in AD"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:500,100,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css></head><body><div class="container wrapper post"><div class=header><a href=/><img src=/images/header.png alt="Break things, write reports"></a><div class=site-description></div><nav class=nav><ul class=flat><li><a href=/>home</a></li><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li></ul></nav></div><div class=post-header><h1 class=title>Password Audit and Control Guidance - Active Directory</h1><h3><blockquote>Stopping users from having stupid passwords in AD</blockquote></h3><div class=meta>Tags &mdash; |
<a href=/tags/passwords/>passwords</a> |
<a href=/tags/windows/>windows</a> |
<a href=/tags/active-directory/>active-directory</a> |
Categories: &mdash;
<a href=/categories/windows/>windows</a> |</div><div class=meta>Posted at &mdash; Jul 16, 2019</div></div><div class=markdown><h2 id=tldr>Tldr</h2><p><a href=https://docs.microsoft.com/en-us/windows/win32/secmgmt/password-filters>Password filters</a></p><h2 id=less-tldr>Less tl;dr</h2><p>I keep finding loads of password reuse in target environments. This is particularly common in users that keep low and high privileged accounts, and the practice generally results in trivial privilege escalation within the environment. This practice provides an “easy win” for an attacker, and serves to undermine an organisation’s security programme and the effectiveness of its defence-in-depth controls. I <em>think</em> the following could help solve the problem, or at least work towards making it significantly less bad (Although you only need one win as an attacker for password reuse).</p><h3 id=the-problem>The problem</h3><p>Poor user security practices, such the selection of weak passwords and their reuse across multiple accounts, are providing attackers with easy access and trivial privilege escalation capability within an environment.
When a standard user account shares credentials with a higher-level account, such as one for an administrator to a group of servers, it can lead to substantial lateral movement for an attacker. This is especially true in the case of the user being a member of domain admin or a similar highly privileged group.
A contributing factor to the ease of privilege escalation is the account naming schemes for user accounts, as they can make it trivial to escalate within an environment whilst generating minimal noise – at best, a single login event.
The problem is significantly worse in environments with forest-level trusts in Active Directory which, by default, do not allow either side to masquerade as other users within the other foresti. This means that, when password reuse occurs, it generally results in a foothold within the other forest.</p><p>The problem poses the following questions:</p><ul><li>How many users are using the same credentials across accounts? (In particular, do administrators use the same credentials across their non-administrative accounts?)</li><li>How many users use ‘weak’ credentials that could be easily guessed or cracked by an attacker?</li></ul><h3 id=the-solution>The solution</h3><p>Two ideas:</p><ul><li>Password auditing. The suggested process can be performed periodically to measure the extent of the problem within an environment.</li><li>Prevention controls. The suggested mechanisms can be implemented to increase the sophistication of password complexity requirements and to prevent password reuse within the environment. (It should be noted that these options require modification to key authentication mechanisms within the environment; namely the domain controllers.)</li></ul><h3 id=risks>Risks</h3><ul><li>Any information extracted from Active Directory that is not adequately controlled (i.e. through loss, theft or the improper clean-up of an analysis host) increases the likelihood of a malicious internal or external party obtaining and using the credential information to move through the environment. The impact of such a compromise can be substantial due to Pass the Hashi style attacks.</li><li>Consequently, when the credential data is in a hashed state it can still be used to successfully authenticate to systems.</li><li>I don&rsquo;t think Microsoft endorse this kind of thing at all, even though with password filters they&rsquo;ve made it pretty easy.</li></ul><h2 id=doing-an-audit>Doing an Audit</h2><p>The process can be broken the following components.</p><ul><li>Audit. Obtaining and analysing credentials:<ul><li>Offline vs online credential gathering mechanisms.</li><li>Domain controller selection.</li><li>Analysis host selection.</li><li>Credential types.</li></ul></li><li>Technical. Controls to prevent poor password selection and reuse:<ul><li>Preventing weak passwords.</li><li>Preventing cross-account password reuse.</li><li>Inter-forest considerations.</li></ul></li></ul><h3 id=obtaining-creds>Obtaining creds</h3><p>Three options are listed here as mechanisms for performing credential gathering: DCsync; recovery from NTDS.DIT; and reversible encryption. The first (DCsync) and third (reversible encryption) options are online mechanisms, whereas the second (recovery from NTDS.DIT) can be performed offline.
Offline analysis is the preferred option, as the audit can be performed without environment interaction, which prevents the introduction of tools to the corporate environment as well as the generation of alerts that require investigation. If the environment maintains backups of its key infrastructure, the recommended approach would be to retrieve domain controller backup for the credentials analysis.</p><h4 id=dcsync>DCsync</h4><p>This option entails abusing the well-known API call ‘IDL_DRSGetNCChanges’i over a network to a domain controller, via a technique known as DCSync. The API call needs high level privileges (generally domain administrator) and can be used to download all users’ credentials. This can be achieved with tools such as Mimikatz, however that approach replicates common attack strategies which should not generally be ignored by a security team.</p><h4 id=recovery-from-ntdsdit>Recovery from NTDS.DIT</h4><p>This option involves taking an existing, recent backup of a domain controller, then recovering the ntds.ditiv file, SAM, SYSTEM and SECURITY registry hives onto a separate machine. Tools such as Impacket’sv SecretsDump.py can be used to dump the hashed credentials out of the Active Directory database. If backups are not available, this could also be performed online using inbuilt Windows utilities such as Volume Shadow Copy to retrieve the files, which can then be processed with the Impacket tooling.</p><h4 id=reversible-encryption>Reversible encryption</h4><p>This option uses a known feature in Active Directory that stores passwords with reversible encryption, however the encryption only takes effect after the user has changed their password. This would bypass the requirement to crack credentials and determine patterns against the entire dataset.</p><p><code>Note. With this approach, passwords are effectively stored plaintext. As such, this option may be unappealing, particularly for risk averse organisations. Also, it seems like terrible advice</code></p><h4 id=selecting-a-dc>Selecting a DC</h4><p>Any domain controller for the domain that is to be audited is sufficient for obtaining credentials, with one exception. The selection of a read-only domain controller would not be suitable, as it would only retain credentials for select accounts as per its configurable replication policy. In the case of multiple domains, a domain controller from each domain would need to have credentials extracted.</p><h3 id=analysing-credentials>Analysing credentials</h3><h4 id=host-selection>Host selection</h4><p>Once credentials have been obtained and transferred to a suitable host, connecting the device to the network increases the risk of an attacker retrieving credentials for the entire domain through the compromise of that single host.</p><p>For this reason, analysis will ideally be performed on an air-gapped device, whether it be a workstation or special purpose server. The secure transfer of data to the host could be performed via a USB storage medium that is then promptly erased upon confirmation that the Active Directory database and relevant components have been successfully transferred to the secured host.</p><p>Ideally, the analysis host would have several high-performance GPUs to facilitate password cracking (see Appendix - Hardware considerations). However, as the passwords are unsalted, a simple script to compare hashes would identify any passwords that are used across multiple accounts.</p><p><code>Note: The analyst that performs this procedure will have derived domain admin (or any group) membership for all domains for which they have an exported dataset.</code></p><h4 id=credential-types>Credential types</h4><p>Active Directory holds multiple types of accounts that will also be extracted during the credentials gathering process. Although analysis primarily sticks to “human” user accounts, awareness of the other types of accounts and edge cases is important.</p><p>When exporting credentials from Active Directory, the following form of usernames will be observed.</p><ul><li>Accounts not ending in a dollar sign (e.g. USERNAME);</li><li>Accounts ending in a single dollar sign (e.g. DEVMACHINE$); and</li><li>Explicitly named account ‘krbtgt’.</li></ul><p>Accounts without a dollar sign are generally user accounts, and will therefore form the bulk of the analysis.</p><p>Accounts ending in a dollar sign are either machine accounts or Active Directory trust keys. Both are randomly generated, will automatically change periodically, and are of little interest for analysis. These accounts should not be included in statistical analysis or overall totals.</p><p>One special account needs to be mentioned – the ‘krbtgt’ account. This account is used for Kerberos and will also have a randomly generated password, however this credential does not change. If this account hash is compromised, it can result in a situation where an attacker can create legitimate Kerberos tickets for valid accounts and set permissions which do not necessarily reflect “real” Active Directory permissions.</p><h3 id=controls-to-prevent-poor-password-selection>Controls to prevent poor password selection</h3><p>Although password policies in Active Directory can have complexity enabled, users can still select known bad passwords that, although comply with complexity requirements, are considered weak. The inbuilt complexity functionality is able define a minimum length and require inclusion of some or all character class types (lower alpha, upper alpha, numeric, and symbol), however it cannot prevent the use of common strings such as the organisation name or ‘password’</p><p><code>Note: While passwords such as ‘Summer2019!’ will meet most complexity policies, they are not considered strong passwords. Common strings and predictable variations are repeatedly observed in testing engagements, and provide attackers with an easy, low-privileged foothold within an environment</code></p><h4 id=preventing-weak-passwords>Preventing weak passwords</h4><p>To combat the inflexibility of Active Directory’s inbuilt password policy, multiple open source projects have been created to address its limitations. The most notable of these is OpenPasswordFilteri.
The solution follows these steps.</p><ul><li>On a password change event, the password is sent to a domain controller.</li><li>The domain controller checks the unencrypted password against the inbuilt password policy.</li><li>The domain controller checks the unencrypted password against every loaded Password Filter.</li></ul><p>As such, the solution can be configured to:</p><ul><li>outright block a given password (e.g. Summer2018); and</li><li>block passwords with a given a partial string (e.g. block any password with ‘Welcome’ or ‘Summer’).</li></ul><p>Implementation requires some modification to domain controllers. Specifically, it requires the installation of a service to manage a list of bad passwords (and partial matches), and then the loading of a dynamic linked library (DLL) into the Local Security Authority Subsystem Service (LSASS) at boot. This must be performed on all domain controllers for the domain.</p><p><code>Note. The degree of supportability for this solution from Microsoft is uncertain; however, as this method is published on MSDN, it is assumed to be endorsed.</code></p><h4 id=preventing-cross-account-password-re-use>Preventing cross-account password re-use</h4><p>While not a specific goal of the Open Password Filter project, modifications can be made to the solution to stop users from reusing the same password in the domain.
A simple approach could be as follows.</p><ul><li>Automatically export and ingest the entire domain’s worth of password hashes periodically into the password comparison service.</li><li>Compare incoming password changes (after hashing) to the hashed password dataset, rejecting if a matching password exists.</li></ul><p>This simple process would be user agnostic and would therefore not require mapping between a given user account and any standard or administrative equivalents. However, this simple approach may not be ideal for reasons such as:</p><ul><li>There is a potential to bypass the process under circumstances where an administrative user resets both an unprivileged and privileged account within the hash loading period; and</li><li>as a user agnostic approach, a failed password change for one user could inform them of its existing use and prompt the spraying of the password against the domain to find the matching username.</li></ul><p>A more complex process could compare the incoming password against a matching username, providing the account names are programmatic and derivable from non-privileged accounts.</p><p><code>Note. Implementation of this type of solution should be limited to domain controllers; any host that would be sent passwords for comparison would need to be treated as a domain controller. Additionally, the solution’s tuning could increase the level of alerting to which a security team would need to be aware.</code></p><h4 id=cross-domain-applicability>Cross domain applicability</h4><p>These technical controls would not provide a cross domain solution without some modification and serious thought. A naïve implementation might store credentials for a separate forest, which would result in breaking the forest security boundary.</p><p>A different approach could involve an automated process that attempts to log into the other domain with the credentials given on a password reset – this could be filtered to specific accounts matching a regular expression (i.e. privileged only). If a successful login occurs in the other forest, the password’s cross-forest reuse is identified can then be rejected. This solution would generate parallel domain login events which would need to be acknowledged by a security team.</p></div></div><div class="footer wrapper"><nav class=nav><div></div></nav></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-141761824-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>