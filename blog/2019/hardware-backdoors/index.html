<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Sitting in hardware - Pentester, wtf!?</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Sitting in hardware"><meta property="og:description" content="A tl;dr summary on System Management Mode (SMM), light covering on hardware backdoors and forensic capabilities"><meta property="og:type" content="article"><meta property="og:url" content="/blog/2019/hardware-backdoors/"><meta property="article:published_time" content="2019-02-02T12:30:00+00:00"><meta property="article:modified_time" content="2019-02-02T12:30:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sitting in hardware"><meta name=twitter:description content="A tl;dr summary on System Management Mode (SMM), light covering on hardware backdoors and forensic capabilities"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:500,100,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css></head><body><div class="container wrapper post"><div class=header><a href=/><img src=/images/header.png alt="Break things, write reports"></a><div class=site-description></div><nav class=nav><ul class=flat><li><a href=/>home</a></li><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li></ul></nav></div><div class=post-header><h1 class=title>Sitting in hardware</h1><h3><blockquote>A tl;dr summary on System Management Mode (SMM), light covering on hardware backdoors and forensic capabilities</blockquote></h3><div class=meta>Tags &mdash; |
<a href=/tags/hardware/>hardware</a> |
<a href=/tags/smm/>smm</a> |
<a href=/tags/Yuriy%20Bulygin/>Yuriy Bulygin</a> |
<a href=/tags/Oleksandr%20Bazhaniuk/>Oleksandr Bazhaniuk</a> |
<a href=/tags/deepwatch/>deepwatch</a> |
<a href=/tags/platform%20security/>platform security</a> |
Categories: &mdash;
<a href=/categories/Hardware/>Hardware</a> |
<a href=/categories/incident-response/>incident-response</a> |
<a href=/categories/backdoors/>backdoors</a> |</div><div class=meta>Posted at &mdash; Feb 2, 2019</div></div><div class=markdown><p>A tl;dr summary on System Management Mode (SMM), light covering hardware backdoors. Check out <a href=http://www.c7zero.info>www.c7zero.info</a></p><p>This all started with a blog post on <a href=http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html>building a reliable SMM backdoor</a>, but went into a rabbit hole. These were my notes when reading into it.</p><p>My understanding of sitting in SMM is:</p><ul><li><a href=https://en.wikipedia.org/wiki/System_Management_Mode>System Management Mode (SMM)</a> &ldquo;pauses&rdquo; the OS, then runs its own code<ul><li>Pause - Comes as a &lsquo;System Management Interrupt (SMI)&rsquo;, highest priority, can&rsquo;t be masked</li></ul></li><li>Copied into memory at power-on(DXE phase? PEI?), then locked to SMM only use (D_LCK)</li><li>Internals: Theres a internal-only CPU register for SMBASE (Where SMM code gets stored)</li><li>You&rsquo;ve got full read/write of all memory (just swap from real to long mode)</li><li>Theres no way of picking this up (in memory, at least) from the OS</li></ul><p>Summarised: It&rsquo;s a pretty good place to sit in, you&rsquo;re not going to be observed when running.</p><p>In terms of when it spins up:</p><ul><li>UEFI has 3 boot phases (SEC, PEI, DXE)</li><li>SEC(urity) - Verify components, four responsibilities<ul><li>handle boot/restart event - (There&rsquo;s a bunch of bugs in S3 resume, leading to some <a href=https://github.com/abazhaniuk/Publications/blob/master/2015/WP_Intel_ATR_S3_ResBS_Vuln.pdf>cool bugs</a>)</li><li>create temporary memory map using cpu registers - Cache-As-Ram</li><li>start Root of Trust</li><li>hand pointers to PEI</li></ul></li><li>PEI (Pre-EFI initialisation) - goal is to initialise memory for DXE phase<ul><li>Uses PEI Modules (PIEM)</li><li>These are stored in Flash (Flash file system)</li><li>PIEMs are PE&rsquo;s or TE&rsquo;s (Smaller, and also has a VZ header rather than MZ header)</li><li>Describing memory in Hand Off Blocks (HOBS) - describes firmware volume (PI FFS, has a guid, linked to a DXE Driver)</li><li>Notably, this also handles resuming from S3</li></ul></li><li>DXE (Driver Execution Environment) - SMM starts here!<ul><li>Initialise system components (Chipsets, add-on cards), then hand over to an Architecture Protocol (i.e. boot selection)</li><li>3 elements, DXE core, DXE Services, DXE Dispatcher</li><li>DXE Core - produce the boot runtime (DXE Services), populate EFI system table, create handle database</li><li>DXE Services - Consume HOBS, creates Architecture Protocol (Boot selection)</li><li>DXE Dispatcher - Ties a HOB(&rsquo;s GUID) to a DXE driver, which will then boot the driver</li><li>Pretend the DXE phase is an Option ROM in legacy bios</li><li>This is a good place for persistence :)</li></ul></li></ul><p>Unrelated to this, the rest of the UEFI booting seems to be:</p><ul><li>BDS/TSL/RT<ul><li>BDS (Boot Device Selection) is where you could consider the human interacts - (ie, a boot menu/setup menu)</li><li>if BDS fails, it&rsquo;ll go back to DXE and look for different HOBs to try</li></ul></li><li>TSL (Transient System Load) - ie, EFI shell, or OS bootloader runs here. These are generally EFI applications, stored under <code>/EFI/BOOT/BOOT</code></li><li>RT (Runtime) - OS executed, provide services to OS for UEFI management/runtime (Will call ExitBootServices() at this point)</li></ul><p>Deploying things to the actual host:</p><ul><li>Flash to SPI, physical access (chip programmer, et al)</li><li>Firmware &lsquo;upgrade&rsquo; (code signing might stop this?)<ul><li>According to a 2017 paper <a href=https://github.com/abazhaniuk/Publications/blob/master/2017/44CON_2017/Bulygin_Bazhaniuk_44con.pdf>Discovering Vulnerable UEFI firmware at scale</a>, code signing (on UEFI) isn&rsquo;t really used on a sizeable number of systems (or system flash is writeable by software, or will let you write over SPI)</li><li>Sample size was 32987 UEFI packages, with 21204 unique UEFI images (~3417 images were vulnerable)</li></ul></li></ul><p>Unsure when to detect this kind of thing - If you&rsquo;re lucky you might be able to dump UEFI out of SPI flash and find things that way? [Edit: It looks like the intel team made a tool for this exact thing, <a href=https://github.com/chipsec/chipsec>chipsec</a>. ]</p><p>Is anyone looking for this stuff when doing IR? I didn&rsquo;t see any content in SANS (<a href=https://digital-forensics.sans.org/community/papers/grem/analysis-building-blocks-attack-vectors-unified-extensible-firmware-interface-uefi_1018>sans this paper</a> - Which described the attack surface, but no courses on the matter. Lazy googling of popular forensics tools (encase) looked like it was also not a consideration.</p><p>Some research has been done into detection <a href=http://www.hakim.ws/BHUSA08/speakers/Bulygin_Detection_of_Rootkits/bh-us-08-bulygin_Chip_Based_Approach_to_Detect_Rootkits.pdf>Chip based approach to detect rootkits, 2007 - &lsquo;deepwatch&rsquo;</a> - Intels idea of using a seperate microcontroller to do detection, but it doesn&rsquo;t appear like this ever went anywhere (or was adopted in a widespread manner). There&rsquo;s also a cool paper on the <a href=https://www.dfrws.org/sites/default/files/session-files/pres-acquisition_and_analysis_of_compromised_firmware_using_memory_forensics.pdf>Acquisition of compromised firmware using memory analysis (2015)</a>.</p><p>According to the paper:</p><ul><li>On dumping firmware (non-SMM, AMT, etc)<ul><li><code>Major OS like windows, Linux and OSX don't consider firmware regions to be RAM</code></li><li>You can pull off dumping firmware via PCI Introspection</li><li><code>winpmem</code> has been able to do this since 2016</li></ul></li></ul><p>The same names keep popping up in this sphere (Yuriy Bulygin, Oleksandr Bazhaniuk), which propose quite a few cool ideas (time measurement), They appear to have quite a bit of research - <a href=http://www.c7zero.info/>http://www.c7zero.info/</a></p><p>There&rsquo;s also the question of <a href=https://invisiblethingslab.com/resources/bh09usa/Ring%20-3%20Rootkits.pdf>AMT</a> or just flashing firmware on other devices</p><p>The posts I&rsquo;m referring to are:</p><ul><li><a href=http://www.c7zero.info/stuff/Platform%20Firmware%20Security%20Assessment%20wCHIPSEC-csw14-final.pdf>http://www.c7zero.info/stuff/Platform%20Firmware%20Security%20Assessment%20wCHIPSEC-csw14-final.pdf</a></li><li><a href=https://cansecwest.com/slides/2015/A%20New%20Class%20of%20Vulnin%20SMI%20-%20Andrew%20Furtak.pdf>https://cansecwest.com/slides/2015/A%20New%20Class%20of%20Vulnin%20SMI%20-%20Andrew%20Furtak.pdf</a></li><li><a href=https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf>https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf</a></li><li><a href=http://opensecuritytraining.info/IntroBIOS_files/Day1_08_Advanced%20x86%20-%20BIOS%20and%20SMM%20Internals%20-%20SMRAM.pptx>http://opensecuritytraining.info/IntroBIOS_files/Day1_08_Advanced%20x86%20-%20BIOS%20and%20SMM%20Internals%20-%20SMRAM.pptx</a></li></ul></div></div><div class="footer wrapper"><nav class=nav><div></div></nav></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-141761824-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>